
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>DB 락의 커넥션 점유 확인과 해결 / 점유 시간을 줄이기 위한 노력</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">DB 락의 커넥션 점유 확인과 해결 / 점유 시간을 줄이기 위한 노력</h2>
                                <div class="box-info">
                                    <p class="category">Architecture/Application</p>
                                    <p class="date">2024-01-23 17:27:22</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h4 data-ke-size="size20"><span style="color: #333333;"><b>비관적 락과 DB Connection 점유</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;"><a style="color: #333333;" title="이전 글" href="https://www.blog.ecsimsw.com/entry/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88" target="_blank" rel="noopener">이전 글</a> 에서 프로젝트에서 생긴 동시성 문제가 왜 발생했는지 소개하고 이를 해결할 수 있는 락 종류를 소개했다. 추가적인 인프라와 적은 코드 수정, 그리고 확실한 동시성 문제 처리를 원했기에 비관적 락을 선택했다. 인덱스 조건을 수정하여 사용자별 로우락을 유도해 불필요한 대기를 없앴다. </span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333;">그리고 다음 날 샤워하면서 <b>대기 시간동안 커넥션을 물고 있겠구나</b>가 그제야 떠올랐다. 사용자 간 독립적으로 락 처리를 했지만, 한 사용자가 락으로 모든 커넥션을 물고 있으면 <b>결국 락이 걸린 로우와 독립적인 다른 사용자는 그 사용자를 대기해야</b> 할 테니 말이다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333; text-align: start;">이 글에서는 커넥션이 모두 점유되는 예상 시나리오를 확인하고 이를 해결 할 수 있는 어떤 다른 방법들이 있는지, 어떻게 해결했는지 소개하려 한다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="color: #333333;"><b>락으로 커넥션이 모두 점유되는 경우를 확인한다</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;">락으로 커넥션이 점유되는 것을 확인한다. 직접 확인하고 싶은데 DB 쿼리로 실제 커넥션이 물리고 있는 시간은 워낙 짧으니 트랜잭션을 직접 실행하고 배타락을 잡아 확인했다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="sql" data-ke-type="codeblock" data-ke-language="sql"><code>start transaction;
select * from storage_usage where user_id=1 for update;
commit;</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">그리고 user_id=1 에 대한 storage_usage 업데이트 요청을 DB connection pool 의 최대 커넥션 개수보다 많이 한다. 프로젝트에선 hikariCP 를 사용했고 기본 Connection pool size인 10을 넘어 50개를 요청을 요청하면 아래와 같이 10개의 커넥션이 모두 점유된 채로 대기할 것이다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="sql" data-ke-type="codeblock" data-ke-language="sql"><code>activeConnections : 10
idleConnections : 0
waitingConnections : 40</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">이때 다른 DB 커넥션을 사용하는 요청이 발생하는 경우 idle 커넥션이 생길 때까지 대기하게 되고, 다른 사용자도 한 사용자의 동시성 문제 해결을 위한 락에 영향을 받게 되는 상황이 발생하는 상황이 발생한다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">위 테스트에서 직접 수행한 트랜잭션의 배타락을 제거하면 (commit 을 수행하면), 락 때문에 수행되지 못하고 대기하던 transaction 들이 순차적으로 처리되어 waitingConnections가 40부터 39, 38, 37 ... 1 으로 내려가는 것을 확인할 수 있다. 그렇게 idleConnections 이 생길 때까지 사용자에 상관없이 어떤 DB 요청도 처리되지 못하고 병목 된다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<h4 data-ke-size="size20"><span style="color: #333333;"><b>대기 시 커넥션 점유 없이 동시성 문제를 해결하기 위한 구조들</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;">문제가 발생했을 때 다른 트랜잭션을 기다리는 동안 DB 커넥션을 놓고 대기하는 방법으로 동시성 문제 해결 방식을 바꿀 생각이다. 분산 환경에서 DB 락이 아닌 방식으로 동시성 문제를 해결을 위해 떠오른 네 가지 구조를 그려보았다.&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignCenter" width="632" height="400" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" width="632" height="400"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><br /><span style="color: #333333;">첫 번째는 <b>성공할 때까지 액세스를 반복하는 것이다</b>. 일단 동시성 문제가 발생하지 않는다고 생각하고 공유 자원에 접근하고 버전 정보와 같이 동시성 문제를 확인할 수 있는 방법을 사용해서 문제가 발생하지 않는 경우만 자원을 실제로 변경하는 것이다. 문제가 발생하면 롤백하고 재시도하거나 문제 자체를 회피한다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">앞선 방식은 공유 자원을 지속적으로 엑세스 한다. 공유 자원이 DB라면 반복되는 엑세스 비용도 큰데다 커넥션도 점유할 것이고 롤백 처리도 큰 비용이다. 두 번째 방식으로 <b>공유 자원보다 비용이 적은 공유 자원을 엑세스 가능 여부 기록에 사용</b>해서 엑세스 비용과 롤백 비용을 줄일 수 있을 것 같다. 예를 들면 HDD DB가 공유 자원인 상황이라면, 그보다 비용이 덜한 레디스로 공유 자원의 현재 사용 여부를 기록하고 WAS 에선 이 기록을 지속적으로 확인하고 사용 가능하면 그제야 실제 데이터에 엑세스하는 것으로 첫번째 방식보다 DB 액세스는 줄이는 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignCenter" width="630" height="397" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" width="630" height="397"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><br /><span style="color: #333333;">세 번째 방식은 <b>공유 자원이 지금 사용 가능함을 알리는 방식</b>이다. 사용자가 중간 Publisher 에게 Release 여부를 알리면, Publisher는 대기자들에게 사용 가능함을 전달한다. 대기자들은 자원에 액세스를 시도하고 성공한 사용자는 자원을 사용, 실패한 사용자는 다시 대기자가 된다. 대기자들이 모두 시도하기에 두 번째 방식보다 DB 엑세스는 많아지지만 Cache 를 지속적으로 액세스 하지 않아도 된다.&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">네 번째 방식은 <b>pub/sub 을 처리할 수 있는 중간 매니저를 두는 방식</b>이다. 사용자가 공유 자원의 사용을 마치면 매니저에 자원 사용 마침을 알린다. 매니저는 이 자원을 대기하고 있는 대기자를 확인하고 다음 순서의 대기자에 이벤트를 전달하는 것으로 다음 사용자는 공유 자원을 사용할 수 있다. 대표적으로 Redisson 을 사용할 수 있다. 대신 Redisson 을 설정하고 Redis 를 인프라에 추가해야 할 것이다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<h4 data-ke-size="size20"><span style="color: #333333;"><b>낙관적 락과 재시도, 트랜잭션 분리</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;">해결할 수 있는 여러 구조와 장단을 고민해 보았다. 그리고 첫 번째 방식인 버전을 이용한 동시성 문제 확인과 문제 발생 시 재시도로 동시성 문제를 풀이하는 것으로 결정하였다. 동시성 문제가 발생하는 경우가 워낙 적기에 성능은 조금 덜 고려해도 다른 인프라나 설정을 추가하지 않고 가장 명확한 해결 방식을 사용하고 싶었다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="java" data-ke-type="codeblock" data-ke-language="java"><code>@Retryable(
&nbsp;&nbsp;&nbsp;&nbsp;value = ObjectOptimisticLockingFailureException.class,
&nbsp;&nbsp;&nbsp;&nbsp;maxAttempts = 3,
&nbsp;&nbsp;&nbsp;&nbsp;backoff = @Backoff(delay = 100),
&nbsp;&nbsp;&nbsp;&nbsp;recover = "recoverCreate"
)
@Transactional
public AlbumInfoResponse updateUsage(Long userId, FileResourceInfo resource) {
}</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">처음 비관적 락을 선택한 이유는 '재시도 처리를 위한 코드 추가를 피하고 싶어서' 가 가장 컸다. DB 락을 사용하는 것으로 재시도 처리를 위한 코드가 복잡해져서 오히려 동시성 문제를 처리하는 방법이 명확하지 않고 코드가 더러워지는 상황을 피하고 싶었다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">낙관적 락을 선택한 지금은 @Retryable 으로 코드 추가를 줄이고 재시도 정책을 명확하게 보이려고 했다. 위 코드 예시에서 예외가 발생했을 때 0.1초의 delay와 함께 3회 반복함을 명확히 확인할 수 있다. 그리고 끝내 처리에 실패하는 경우 사용자에게 너무 많은 동시 요청임을 알리며 처리 실패를 응답하도록 하였다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<p><figure class="imageblock alignCenter" width="784" height="332" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" width="784" height="332"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333;">그렇다고 아예 코드 수정이 없는 건 아니다. JPA 의 <b>낙관적 락은 트랜잭션이 커밋되는 시점에서 버전을 확인</b>한다. 프로젝트에서 기본 전파 유형인 Propagation.REQUIRED 을 사용했기에 최상위 @Transactional 을 감싸 예외처리, @Retryable 을 해야했다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">위 그림처럼 기존 방식은 최상위 트랜잭션에 이미지 파일 업로드와 예외 시 이미지 파일을 제거하는 보상 이벤트 처리가 있었는데, 이번 낙관적 락을 도입하면서 락이 필요한 최상위 트랜잭션에 재시도가 처리되어야 했고, 이미지 파일을 업로드는 재시도되기엔 느리기에 두 로직을 각각의 트랜잭션으로 분리하게 되었다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">락 대기에서 DB 커넥션 점유 없이 동시성 문제를 해결할 수 있었다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<h4 data-ke-size="size20"><span style="color: #333333;"><span style="background-color: #ffffff;"><b>커넥션 점유 시간을 줄이기 위한 노력들</b></span><span style="background-color: #ffffff;"><b></b></span></span></h4>
<p data-ke-size="size16"><span style="color: #333333;"><span style="background-color: #ffffff;">Spring 에서는 기본적으로 트랜잭션 진입과 동시에 커넥션을 가져오는데 이는 DB 사용이 불필요한 경우에서도 커넥션을 확보하고, 필요한 시간보다 커넥션 점유 시간을 크게 한다. </span><span style="background-color: #ffffff;"></span><span style="background-color: #ffffff;"><b>LazyConnectionDataSourceProxy</b></span><span style="background-color: #ffffff;"> 을 사용하면 커넥션이 필요한 시점에 얻도록 하여 불필요한 커넥션 점유를 막고, 점유 시간을 줄일 수 있다.</span></span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><span style="background-color: #ffffff;"><b>OSIV</b></span><span style="background-color: #ffffff;"> 는 View 까지 영속성 컨텍스트를 지속하고 DB 컨넥션을 유지하여 View 에서도 엔티티의 Lazy loading으로 인한 쿼리가 가능하도록 한다. 기본적으로 설정되어 있는 OSIV를 </span><span style="background-color: #ffffff;">Off 하는 것으로 View 까지 영속성 컨텍스트가 지속되어 트랜잭션 범위 밖으로 Connection 이 물고 있는 상황을 막을 수 있다.</span></span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span></p>
<p><figure class="imageblock alignCenter" width="731" height="278" >
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" width="731" height="278"  />
    </span>
    <figcaption>OSIV 설정이 On 일 때 영속성 컨텍스트 범위</figcaption>
</figure></p>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><b>DB 커넥션을 늘리거나 부하를 분산</b>하는 것도 좋은 방법이 될 것이다. 예를 들어 독립적인 데이터라서 DB 가 분리되는 경우 DB 서버를 나눠 커넥션을 따로 가져가는 것으로 커넥션을 늘리거나, 레플리케이션을 적용하여 라우팅 규칙에 따라 DataSource 를 달리하면 커넥션을 늘리고 점유를 분산할 수 있을 것이다.</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span></p>
<p><figure class="imageblock alignCenter" width="745" height="374" >
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" width="745" height="374"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><span style="background-color: #ffffff;">마지막으로&nbsp;</span><span style="background-color: #ffffff;">캐시를 활용하여</span><span style="background-color: #ffffff;"> </span><span style="background-color: #ffffff;">DB 액세스 횟수를 줄이거나 쿼리 튜닝이나 인덱스 설정, 락 범위를 확인 등 근본적인 DB 처리 시간을 줄이는 것으로 커넥션 사용 횟수와 점유 시간을 줄일 수 있겠다.</span></span><br /><span style="color: #333333;">&nbsp;</span></p>
<h4 data-ke-size="size20"><span style="background-color: #ffffff; color: #333333;"><b>댓글 답변 1 ) HikariCP 상태를 확인하는 방법</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;"><b>1.&nbsp;</b><span style="background-color: #ffffff;"><b>HikariCP 로그 출력</b></span></span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="java" data-ke-type="codeblock" data-ke-language="java"><code>logging.level.com.zaxxer.hikari=TRACE
logging.level.com.zaxxer.hikari.HikariConfig=DEBUG</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">위를 Application 설정에 추가하는 것으로 Pool 상태를 확인할 수 있다.&nbsp;30초에 한번씩 아래와 같이 총 커넥션, 현재 사용 중인 커넥션, 놀고 있는 커넥션, 대기 중인 커넥션이 로그로 남는다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<blockquote data-ke-style="style2"><span style="color: #333333;">2024-01-26T21:34:28,983 DEBUG [HikariPool-1 housekeeper] c.z.h.p.HikariPool: HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)</span></blockquote>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><b>2. HikariPoolMXBean 으로 직접 로깅</b></span><br /><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><span style="background-color: #ffffff;">JMX MBean for HikariCP 를 사용하여 직접 로그를 출력 할 수 있다.</span><span style="background-color: #ffffff;"><br /></span><span style="background-color: #ffffff;">(</span><a style="color: #333333;" href="https://github.com/brettwooldridge/HikariCP/wiki/MBean-(JMX)-Monitoring-and-Management" target="_self"><span style="background-color: #ffffff;">brettwooldridge -&nbsp;MBean (JMX) Monitoring and Management</span></a><span style="background-color: #ffffff;">)</span></span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="java" data-ke-type="codeblock" data-ke-language="java"><code>spring.datasource.hikari.register-mbeans=true
spring.datasource.hikari.pool-name=pool-name</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">MBean 등록을 true 로 허용하고, hikari pool name을 지정한다.&nbsp;</span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="java" data-ke-type="codeblock" data-ke-language="java"><code>@Bean
public HikariPoolMXBean poolProxy() throws MalformedObjectNameException {
&nbsp;&nbsp;&nbsp;&nbsp;MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
&nbsp;&nbsp;&nbsp;&nbsp;ObjectName objectName = new ObjectName("com.zaxxer.hikari:type=Pool (pool-name)");
&nbsp;&nbsp;&nbsp;&nbsp;return JMX.newMBeanProxy(mBeanServer, objectName, HikariPoolMXBean.class);
}</code></pre>
<p data-ke-size="size16"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;">그리고&nbsp;HikariPoolMXBean 을 빈으로 등록하면 된다. 아래 빈 등록 코드에서 pool-name 은 설정한 pool 이름으로 수정한다.&nbsp;HikariPoolMXBean 의 메서드로&nbsp;총 커넥션, 현재 사용 중인 커넥션, 놀고 있는 커넥션, 대기 중인 커넥션를 얻을 수 있다.</span><br /><span style="color: #333333;">&nbsp;</span></p>
<pre class="java" data-ke-type="codeblock" data-ke-language="java"><code>@Autowired
HikariPoolMXBean hikariPoolMXBean;

public void foo() {
&nbsp;&nbsp;&nbsp;&nbsp;logger.info("\n"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "activeConnections : " + hikariPoolMXBean.getActiveConnections() + "\n"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "idleConnections : " + hikariPoolMXBean.getIdleConnections() + "\n"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "waitingConnections : " + hikariPoolMXBean.getThreadsAwaitingConnection()
&nbsp;&nbsp;&nbsp;&nbsp;);
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="color: #333333;">&nbsp;</span><br /><span style="color: #333333;"><b>댓글 답변 2 ) JdbcTemplate 으로 버전을 통한 동시성 문제 해결 방법&nbsp;</b></span></h4>
<p data-ke-size="size16"><span style="color: #333333;">댓글에서 Mybatis 를 사용하시는데 테스트가 원할하지 않아, JPA가 고립 수준을 바꾸는 등 다른 처리가 있는지 질문해주셨다. <span style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;">JPA의 역할은 수정시 Transaction이 커밋될 때 이전 조회에서 사용한 version 을 where 조건에 추가, version을 업데이트 하는 것이 전부이지 않을까 생각한다.</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;"></span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333;">혹시 빠트린건 없을지 JPA 에서 벗어나 JdbcTemplate 으로 버전 정보를 이용한 동시성 문제 인지를 구현해보았다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1707103450494" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Transactional(isolation = Isolation.REPEATABLE_READ)
public void updateWithVersion(DailyCount dailyCount) {
    int updateRow = jdbcTemplate.update(
        "UPDATE daily_count " +
            "SET today_count = " + dailyCount.getTodayCount() +
            ", version = " + (dailyCount.getVersion() + 1) + " " +
            "WHERE id = " + dailyCount.getId() + " AND " + "version = " + dailyCount.getVersion()
    );
    if(updateRow == 0) {
        throw new IllegalArgumentException("OptimisticLockingFailureException with " + dailyCount.getId());
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333;">테스트 하신 내용부터 상황 공유까지 열정이 대단하시다. </span></p>
<p data-ke-size="size16"><span style="color: #333333;">큰 동기부여를 받았다.</span></p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
